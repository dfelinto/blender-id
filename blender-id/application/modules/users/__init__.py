import datetime
import logging

from flask import jsonify
from flask import request
from flask_security.utils import verify_password
import oauthlib.common

from application import app
from application import db
from application.modules.users.model import UsersRestTokens
from application.modules.users.model import user_datastore

DEFAULT_OAUTH_TOKEN_SCOPE = 'email'
log = logging.getLogger(__name__)


def create_oauth_token(user, host_label):
    """Creates an OAuth token for this user.

    This token is not generated by the OAuth library, but is designed to be accepted by it.

    @param user: the user for whom to create a token.
    @param host_label: a label for identifying the host (i.e. authenticated) application.

    @return: the token object
    @rtype: application.modules.oauth.model.Token
    """

    expires_secs = app.config['OAUTH2_PROVIDER_TOKEN_EXPIRES_IN']
    expires = datetime.datetime.now() + datetime.timedelta(seconds=expires_secs)

    # Late import to prevent circular dependencies
    from application.modules.oauth.model import Token

    tok = Token(
        access_token=oauthlib.common.generate_token(),
        refresh_token=oauthlib.common.generate_token(),
        token_type='Bearer',
        _scopes=DEFAULT_OAUTH_TOKEN_SCOPE,
        expires=expires,
        client_id=app.config['BLENDER_ID_ADDON_CLIENT_ID'],
        user_id=user.id,
        host_label=host_label,
    )
    db.session.add(tok)
    db.session.commit()
    return tok


@app.route('/u/identify', methods=['POST'])
def verify_identity():
    """Entry point that generates an authentication token, given exsiting
    and valid username and password. The token can be used as alternative
    authentication system for REST based services (e.g. Attract).
    """

    username = request.form['username']
    password = request.form['password']
    host_label = request.form['host_label']

    user = user_datastore.get_user(username)

    # Blinding: we're always taking the time to verify a password,
    # so that the caller can't determine whether the username exists
    # or not based on timing of the response.
    if user:
        password_ok = verify_password(password, user.password)
        log.debug('User %r exists but not with the given password', username)
    else:
        verify_password(password, 'fake-password')
        password_ok = False
        log.debug('User %r does not exist', username)

    if not password_ok:
        # TODO Throttle authentication attempts (limit to 3 or 5)
        # We need to address the following cases:
        # - the user already has a token-host_label pair
        # - the user never autheticated before (where do we store such info?)
        return jsonify(status='fail', data={'password': 'Wrong password'})

    token = create_oauth_token(user, host_label)

    return jsonify(
        status='success',
        data={
            'user_id': user.id,
            'oauth_token': {
                'access_token': token.access_token,
                'refresh_token': token.refresh_token,
                'expires': token.expires,
            },
        })


def validate_oauth_token(user_id, access_token, subclient):
    """Validates the given token, returning the User object if valid.

    Only accepts true OAuth tokens, and ignores subclient tokens.

    :return: (user, token) or (None, None) if the token is invalid.
    :rtype: (application.module.users.model.User,
             application.module.users.model.Token)
    """

    log.debug('Validating token for subclient %s, user "%s", token "%s"',
              subclient, user_id, access_token)

    # Late import to prevent circular dependencies
    from application.modules.oauth import expire_tokens
    from application.modules.oauth.model import Token

    filters = {'subclient': subclient,
               'access_token': access_token}
    if user_id:
        filters['user_id'] = int(user_id)

    expire_tokens()
    token_info = Token.query.filter_by(**filters).first()

    if token_info is None:
        return None, None

    # Database constraints ensure that this user actually exists.
    user = user_datastore.get_user(token_info.user_id)

    return user, token_info


@app.route('/u/validate_token', methods=['POST'])
def validate_token():
    """Validate and existing authentication token.

    This is usually called by a third party (e.g. Attract) every few requests
    to confirm the identity of a user.

    Returns further information about the user if the given token is valid.

    The user ID is not used at the moment. The subclient ID can be empty or
    absent from the request, in which a regular OAuth token is verified. If
    the subclient is present, a subclient token is verified.
    """

    subclient = request.form.get('subclient_id')
    user_id = request.form.get('user_id')
    access_token = request.form['token']

    user, token = validate_oauth_token(user_id, access_token, subclient)

    if token is None:
        log.debug('Token not found in database.')
        return jsonify({'status': 'fail',
                        'token': 'Token is invalid'}), 403

    user = token.user
    return jsonify({'status': 'success',
                    'user': {'id': user.id,
                             'email': user.email,
                             'full_name': user.full_name},
                    'token_expires': token.expires,
                    }), 200


@app.route('/u/delete_token', methods=['POST'])
def delete_token():
    """Delete a token for a certain user_id. This can be turned into a proper
    RESTful request by making it a DELETE method and checking the identity
    via the header.
    """

    user_id = request.form['user_id']
    token = request.form['token']

    # Late import to prevent circular dependencies
    from application.modules.oauth.model import Token

    oauth_token = Token.query.filter_by(user_id=user_id, access_token=token).first()
    if not oauth_token:
        return jsonify(status='fail', data={'message': 'ole'})

    db.session.delete(oauth_token)
    db.session.commit()

    return jsonify(
        status='success',
        data={'message': 'ole'})
